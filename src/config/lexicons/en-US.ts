// @generated — 由 scripts/generate-lexicons.ts 自动生成，请勿手动修改

import { SemanticTokenKind } from '../token-kind.js';
import type { Lexicon } from './types.js';

export const EN_US: Lexicon = {
  id: 'en-US',
  name: 'English (US)',
  direction: 'ltr',

  keywords: {
    [SemanticTokenKind.MODULE_DECL]: 'Module',
    [SemanticTokenKind.IMPORT]: 'use',
    [SemanticTokenKind.IMPORT_ALIAS]: 'as',
    [SemanticTokenKind.TYPE_DEF]: 'Define',
    [SemanticTokenKind.TYPE_WITH]: 'with',
    [SemanticTokenKind.TYPE_HAS]: 'has',
    [SemanticTokenKind.TYPE_ONE_OF]: 'as one of',
    [SemanticTokenKind.FUNC_TO]: 'Rule',
    [SemanticTokenKind.FUNC_GIVEN]: 'given',
    [SemanticTokenKind.FUNC_PRODUCE]: 'produce',
    [SemanticTokenKind.FUNC_PERFORMS]: 'it performs',
    [SemanticTokenKind.IF]: 'If',
    [SemanticTokenKind.OTHERWISE]: 'Otherwise',
    [SemanticTokenKind.MATCH]: 'Match',
    [SemanticTokenKind.WHEN]: 'When',
    [SemanticTokenKind.RETURN]: 'Return',
    [SemanticTokenKind.RESULT_IS]: 'the result is',
    [SemanticTokenKind.FOR_EACH]: 'for each',
    [SemanticTokenKind.IN]: 'in',
    [SemanticTokenKind.LET]: 'Let',
    [SemanticTokenKind.BE]: 'be',
    [SemanticTokenKind.SET]: 'set',
    [SemanticTokenKind.TO_WORD]: 'to',
    [SemanticTokenKind.OR]: 'or',
    [SemanticTokenKind.AND]: 'and',
    [SemanticTokenKind.NOT]: 'not',
    [SemanticTokenKind.PLUS]: 'plus',
    [SemanticTokenKind.MINUS_WORD]: 'minus',
    [SemanticTokenKind.TIMES]: 'times',
    [SemanticTokenKind.DIVIDED_BY]: 'divided by',
    [SemanticTokenKind.LESS_THAN]: 'less than',
    [SemanticTokenKind.GREATER_THAN]: 'greater than',
    [SemanticTokenKind.EQUALS_TO]: 'equals to',
    [SemanticTokenKind.IS]: 'is',
    [SemanticTokenKind.UNDER]: 'under',
    [SemanticTokenKind.OVER]: 'over',
    [SemanticTokenKind.MORE_THAN]: 'more than',
    [SemanticTokenKind.MAYBE]: 'maybe',
    [SemanticTokenKind.OPTION_OF]: 'option of',
    [SemanticTokenKind.RESULT_OF]: 'result of',
    [SemanticTokenKind.OK_OF]: 'ok of',
    [SemanticTokenKind.ERR_OF]: 'err of',
    [SemanticTokenKind.SOME_OF]: 'some of',
    [SemanticTokenKind.NONE]: 'none',
    [SemanticTokenKind.TRUE]: 'true',
    [SemanticTokenKind.FALSE]: 'false',
    [SemanticTokenKind.NULL]: 'null',
    [SemanticTokenKind.TEXT]: 'Text',
    [SemanticTokenKind.INT_TYPE]: 'Int',
    [SemanticTokenKind.FLOAT_TYPE]: 'Float',
    [SemanticTokenKind.BOOL_TYPE]: 'Bool',
    [SemanticTokenKind.IO]: 'io',
    [SemanticTokenKind.CPU]: 'cpu',
    [SemanticTokenKind.WORKFLOW]: 'workflow',
    [SemanticTokenKind.STEP]: 'step',
    [SemanticTokenKind.DEPENDS]: 'depends',
    [SemanticTokenKind.ON]: 'on',
    [SemanticTokenKind.COMPENSATE]: 'compensate',
    [SemanticTokenKind.RETRY]: 'retry',
    [SemanticTokenKind.TIMEOUT]: 'timeout',
    [SemanticTokenKind.MAX_ATTEMPTS]: 'max attempts',
    [SemanticTokenKind.BACKOFF]: 'backoff',
    [SemanticTokenKind.WITHIN]: 'within',
    [SemanticTokenKind.SCOPE]: 'scope',
    [SemanticTokenKind.START]: 'start',
    [SemanticTokenKind.ASYNC]: 'async',
    [SemanticTokenKind.AWAIT]: 'await',
    [SemanticTokenKind.WAIT_FOR]: 'wait for',
    [SemanticTokenKind.REQUIRED]: 'required',
    [SemanticTokenKind.BETWEEN]: 'between',
    [SemanticTokenKind.AT_LEAST]: 'at least',
    [SemanticTokenKind.AT_MOST]: 'at most',
    [SemanticTokenKind.MATCHING]: 'matching',
    [SemanticTokenKind.PATTERN]: 'pattern',
  },

  punctuation: {
    statementEnd: '.',
    listSeparator: ',',
    enumSeparator: ',',
    blockStart: ':',
    stringQuotes: {
      open: '"',
      close: '"',
    },
  },

  canonicalization: {
    fullWidthToHalf: false,
    whitespaceMode: 'english',
    removeArticles: true,
    articles: ['a', 'an', 'the'],
    allowedDuplicates: [
      [SemanticTokenKind.FUNC_TO, SemanticTokenKind.TO_WORD],
      [SemanticTokenKind.LESS_THAN, SemanticTokenKind.UNDER],
      [SemanticTokenKind.OVER, SemanticTokenKind.GREATER_THAN, SemanticTokenKind.MORE_THAN],
    ],
    preTranslationTransformers: ['english-possessive'],
    postTranslationTransformers: ['result-is'],
  },

  messages: {
    unexpectedToken: 'Unexpected token: {token}',
    expectedKeyword: 'Expected keyword: {keyword}',
    undefinedVariable: 'Undefined variable: {name}',
    typeMismatch: 'Type mismatch: expected {expected}, got {actual}',
    unterminatedString: 'Unterminated string literal',
    invalidIndentation: 'Invalid indentation: must be multiples of 2 spaces',
  },
};
