import { describe, test } from 'node:test';
import assert from 'node:assert/strict';
import { ProvenanceTracker, type ProvenanceMetadata } from '../../src/ai/provenance.js';

// 測試數據
const basicMetadata: ProvenanceMetadata = {
  model: 'gpt-4',
  provider: 'openai',
  prompt: 'Create a simple Hello World policy',
  timestamp: '2025-11-25T00:00:00.000Z',
  validated: true,
};

const simpleCNL = `Module demo.hello.

Rule greet, produce Text:
  Return "Hello, World!".
`;

describe('Provenance Tracker', () => {
  test('應該生成格式正確的註釋頭', () => {
    const tracker = new ProvenanceTracker();
    const header = tracker.generateHeader(basicMetadata);

    assert.ok(header.includes('// ========================================'));
    assert.ok(header.includes('// Generated by: Aster AI Code Generator'));
    assert.ok(header.includes('// Model: gpt-4'));
    assert.ok(header.includes('// Provider: openai'));
    assert.ok(header.includes('// Prompt: Create a simple Hello World policy'));
    assert.ok(header.includes('// Timestamp: 2025-11-25T00:00:00.000Z'));
    assert.ok(header.includes('// Validated: true'));
    assert.ok(header.endsWith('\n')); // 應該以空行結束
  });

  test('應該正確添加 provenance 到代碼頂部', () => {
    const tracker = new ProvenanceTracker();
    const annotated = tracker.addProvenanceToCode(simpleCNL, basicMetadata);

    // 檢查註釋頭在代碼之前
    assert.ok(annotated.startsWith('//'));
    assert.ok(annotated.includes('Module demo.hello.'));

    // 檢查原始代碼完整保留
    assert.ok(annotated.includes(simpleCNL));
  });

  test('應該正確處理包含換行符的 prompt', () => {
    const tracker = new ProvenanceTracker();
    const metadata: ProvenanceMetadata = {
      ...basicMetadata,
      prompt: 'Line 1\nLine 2\r\nLine 3',
    };

    const header = tracker.generateHeader(metadata);

    // 換行符應該被替換為空格
    assert.ok(header.includes('// Prompt: Line 1 Line 2 Line 3'));
    assert.ok(!header.includes('\nLine 2')); // 不應該包含未轉義的換行
  });

  test('應該截斷過長的 prompt', () => {
    const tracker = new ProvenanceTracker();
    const longPrompt = 'a'.repeat(300); // 300 個字符
    const metadata: ProvenanceMetadata = {
      ...basicMetadata,
      prompt: longPrompt,
    };

    const header = tracker.generateHeader(metadata);

    // prompt 應該被截斷為 200 字符 + "..."
    const promptLine = header.split('\n').find(line => line.startsWith('// Prompt:'));
    assert.ok(promptLine);
    assert.ok(promptLine.includes('...'));
    assert.ok(promptLine.length < 220); // 200 + "// Prompt: " + "..."
  });

  test('應該處理多個空格的 prompt', () => {
    const tracker = new ProvenanceTracker();
    const metadata: ProvenanceMetadata = {
      ...basicMetadata,
      prompt: 'Hello    World   with    multiple    spaces',
    };

    const header = tracker.generateHeader(metadata);

    // 多個空格應該被壓縮為單個空格
    assert.ok(header.includes('// Prompt: Hello World with multiple spaces'));
  });

  test('validated 為 false 時應該顯示 false', () => {
    const tracker = new ProvenanceTracker();
    const metadata: ProvenanceMetadata = {
      ...basicMetadata,
      validated: false,
    };

    const header = tracker.generateHeader(metadata);
    assert.ok(header.includes('// Validated: false'));
  });

  test('應該從帶註釋的代碼中提取 provenance', () => {
    const tracker = new ProvenanceTracker();
    const annotated = tracker.addProvenanceToCode(simpleCNL, basicMetadata);

    const extracted = tracker.extractProvenance(annotated);

    assert.ok(extracted, 'Should extract provenance');
    assert.equal(extracted.model, 'gpt-4');
    assert.equal(extracted.provider, 'openai');
    assert.equal(extracted.prompt, 'Create a simple Hello World policy');
    assert.equal(extracted.timestamp, '2025-11-25T00:00:00.000Z');
    assert.equal(extracted.validated, true);
  });

  test('應該從不帶 provenance 的代碼中返回 null', () => {
    const tracker = new ProvenanceTracker();
    const extracted = tracker.extractProvenance(simpleCNL);

    assert.equal(extracted, null);
  });

  test('應該處理部分 provenance 註釋（缺失字段）', () => {
    const tracker = new ProvenanceTracker();
    const partialHeader = `// Model: gpt-4
// Provider: openai
// Timestamp: 2025-11-25T00:00:00.000Z
`;

    const extracted = tracker.extractProvenance(partialHeader);

    // 缺少 Prompt 和 Validated 字段，應該返回 null
    assert.equal(extracted, null);
  });

  test('應該正確提取截斷的 prompt', () => {
    const tracker = new ProvenanceTracker();
    const longPrompt = 'a'.repeat(300);
    const metadata: ProvenanceMetadata = {
      ...basicMetadata,
      prompt: longPrompt,
    };

    const annotated = tracker.addProvenanceToCode(simpleCNL, metadata);
    const extracted = tracker.extractProvenance(annotated);

    assert.ok(extracted);
    assert.ok(extracted.prompt.endsWith('...'));
    assert.ok(extracted.prompt.length <= 203); // 200 + "..."
  });

  test('應該處理空 prompt', () => {
    const tracker = new ProvenanceTracker();
    const metadata: ProvenanceMetadata = {
      ...basicMetadata,
      prompt: '',
    };

    const header = tracker.generateHeader(metadata);
    assert.ok(header.includes('// Prompt: '));
  });

  test('應該處理包含特殊字符的 provider 和 model', () => {
    const tracker = new ProvenanceTracker();
    const metadata: ProvenanceMetadata = {
      model: 'claude-3-5-sonnet-20241022',
      provider: 'anthropic',
      prompt: 'Test prompt',
      timestamp: '2025-11-25T00:00:00.000Z',
      validated: true,
    };

    const header = tracker.generateHeader(metadata);
    assert.ok(header.includes('// Model: claude-3-5-sonnet-20241022'));
    assert.ok(header.includes('// Provider: anthropic'));
  });

  test('生成的代碼應該保持原始代碼的格式', () => {
    const tracker = new ProvenanceTracker();
    const codeWithIndentation = `Module demo.test.

Rule calculate given x: Int, y: Int, produce Int:
  Let sum be x plus y.
  Let double be sum times 2.
  Return double.
`;

    const annotated = tracker.addProvenanceToCode(codeWithIndentation, basicMetadata);

    // 檢查原始代碼的縮進和格式保持不變
    assert.ok(annotated.includes('  Let sum be x plus y.'));
    assert.ok(annotated.includes('  Let double be sum times 2.'));
    assert.ok(annotated.includes('  Return double.'));
  });

  test('generateHeader 和 extractProvenance 應該互為逆操作', () => {
    const tracker = new ProvenanceTracker();
    const annotated = tracker.addProvenanceToCode(simpleCNL, basicMetadata);
    const extracted = tracker.extractProvenance(annotated);

    assert.ok(extracted);
    assert.equal(extracted.model, basicMetadata.model);
    assert.equal(extracted.provider, basicMetadata.provider);
    assert.equal(extracted.timestamp, basicMetadata.timestamp);
    assert.equal(extracted.validated, basicMetadata.validated);
  });
});
